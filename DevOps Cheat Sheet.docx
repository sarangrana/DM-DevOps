------------------------------------------------------------------
				Git
-------------------------------------------------------------------

git config --global user.name "Sarang"
git config --global user.email "sarangrana@gmail.com"
git config --list

git clone https://github.com/sarangrana/godrepo.git
git clone git@github.com:sarangrana/godrepo.git
git status
git add <file-name>
git commit -m "Multiple Instance Code Implemented"

git branch			-	will show local branches
git branch -r			- 	will show all remote branches
git checkout <branch-name>	-	to switch branch
git fetch vs git pull

checkout single branch from remote repo
- git clone --single-branch -b dm6904kompose_simple https://sarangr@bitbucket.org/decisionmines/devops.git


------------------------------------------------------------------
				Kubernetes
------------------------------------------------------------------
Port: Port is the port number which makes a service visible to other services running within the same K8s cluster. 
In other words, in case a service wants to invoke another service running within the same Kubernetes cluster, 
it will be able to do so using port specified against “port” in the service spec file.

Target Port: Target port is the port on the POD where the service is running.

Nodeport: Node port is the port on which the service can be accessed from external users using Kube-Proxy. 
Take a look at following spec defining a sample service:

        apiVersion: v1
        kind: Service
        metadata:
          name: test-service
        spec:
          ports:
          - port: 8080
            targetPort: 8170
            nodePort: 33333
            protocol: TCP 
          selector:
            component: test-service-app
Pay attention to some of the following in above spec:

The port is 8080 which represents that test-service can be accessed by other services in the cluster at port 8080. 
The targetPort is 8170 which represents the test-service is actually running on port 8170 on pods 
The nodePort is 33333 which represents that test-service can be accessed via kube-proxy on port 33333.


1. To remotely access your cluster from another machine
get content of the admin.conf file from /etc/kubernetes/
now on remote machine from which you need to connect, copy this file as "~/.kube/config"

2. To view username and password
kubectl config view will show the user/password you are using when using the kubectl tool.

3.Setting up username and password
kubectl config set-credentials cluster-admin --username=admin --password=admin

4. How to check which pod is running on which node?
kubectl get pods -o wide

5. To access the cluster
gcloud container clusters get-credentials jirautil-cluster --zone us-central1-a --project <project-name>

6. To get cluster information about master, kubeDNS, kubeProxy and kubernetes dashboard
kubectl cluster-info

6. kubectl describe pod <pod-name>
	- to have details about pod


kubectl config use-context <your-context>
kubectl get nodes
kubectl get cs 
	- will show component status
kubectl run <deployment-name> --image=<image-name> --port=80
kubectl get deployments
kubectl expose deployment <deployment-name> --target-port=80 --type=NodePort

kubectl create -f <your-file>.yml
kubectl get pods
kubectl describe pod <pod-name>
kubectl expose pod <pod-name> --type=NodePort
kubectl get svc
kubectl describe svc <your-pod>
	- will give you all details of the service exposed for pods




gcloud container clusters list
	- shows list of clusters
gcloud container clusters get-credentials <cluster-name>



PODS
REPLICA CONTROLLER
REPLICA SET
DEPLOYMENTS





1. kubectl version
	- To check kubernetes version
2. kubectl run <pod-name> --image=<image-name> --port=<port-number>
	- To run a pod from an image on exposing defined port
3. kubectl expose deployment <pod-name> --type=<service-type>
	- To expose deployment, here there are 3 options for <service-type> which are 1.ClusterIP, 2.NodePort, 3.LoadBalancer
4. kubectl get pod
	- To view pods and their status
5. kubectl delete deployment <deployment-name>
	- To delete the deployment
6. kubectl create -f <yaml-file-location>
	- To create new deployment via yaml file
7. kubectl get deployments
	- To list all deployments
8. kubectl describe deployment <deployment-name>
	- To have a detailed view of deployment
9. kubectl get deployment <deployment-name> -o yaml
	- To get yaml generated by kubernetes for given deployment
10. kubectl set image deployment/<deployment-name> <pod-name>=<image-name>:<image-tag>
	- To set image for a given pod running in given deployment
11. kubectl apply -f <yaml-file-location>
	- To update deployment via yaml file
12. kubectl create namespace <namespace-name>
	- To create namespace
kubectl get namespaces
	- To view all namespaces
13. kubectl --namespace=<insert-namespace-name-here> get pods
	- To perform any operation for given namespace
14. kubectl config set-context $(kubectl config current-context) --namespace=<insert-namespace-name-here>

# Validate it
kubectl config view | grep namespace:
	- To set namespace permanently

15. kubectl get pods -l environment=production,tier=frontend
	- To get objects as per the labels 
16. kubectl run nginx --image nginx
	or
    kubectl create deployment nginx --image nginx

	- Run an instance of the nginx container by creating a Deployment object.
17. kubectl delete -f nginx.yaml -f redis.yaml
	- Delete the objects defined in two configuration files
18. kubectl replace -f nginx.yaml
	- Update the objects defined in a configuration file by overwriting the live configuration
19. kubectl get roles
	- To view all the roles configured
20. kubectl get rolebinding SERVICE_ACCOUNT_NAME POD
	- To view all role binding configurations
21. kubectl get clusterrolebinding SERVICE_ACCOUNT_NAME POD
	- To view all the clusterrole bindings
22. kubectl create serviceaccount <service-account-name> --namespace mynamespace
	- To create service account
23. gcloud info | grep Account
	- To know which account you are logged in for Kubernetes
24. kubectl get clusterroles
	- To know the cluster roles
25. gcloud config list
	- To know which user is logged in
26. gcloud config set project <project-name>
	- To set/update project in config
27. kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user $(gcloud config get-value account)
	- To give cluster-admin role to given user
28. kubectl auth can-i get pods --namespace qa --as system:serviceaccount:qa:sa-qa


PODS
$ kubectl get pods
$ kubectl get pods --all-namespaces
$ kubectl get pod monkey -o wide
$ kubectl get pod monkey -o yaml
$ kubectl describe pod monkey
Create Deployments
Create single deployment
$ kubectl run monkey --image=monkey --record
Scaling PODs
$ kubectl scale deployment/POD_NAME --replicas=N
POD Upgrade and history
List history of deployments
$ kubectl rollout history deployment/DEPLOYMENT_NAME
Jump to specific revision
$ kubectl rollout undo deployment/DEPLOYMENT_NAME --to-revision=N
Services
List services
$ kubectl get services
Expose PODs as services (creates endpoints)
$ kubectl expose deployment/monkey --port=2001 --type=NodePort
Volumes
Lits Persistent Volumes and Persistent Volumes Claims:
$ kubectl get pv
$ kubectl get pvc
Secrets
$ kubectl get secrets
$ kubectl create secret generic --help
$ kubectl create secret generic mysql --from-literal=password=root
$ kubectl get secrets mysql -o yaml
ConfigMaps
$ kubectl create configmap foobar --from-file=config.js
$ kubectl get configmap foobar -o yaml
DNS
List DNS-PODs:
$ kubectl get pods --all-namespaces |grep dns
Check DNS for pod nginx (assuming a busybox POD/container is running)
$ kubectl exec -ti busybox -- nslookup nginx
Note: kube-proxy running in the worker nodes manage services and set iptables rules to direct traffic.
Ingress
Commands to manage Ingress for ClusterIP service type:
$ kubectl get ingress
$ kubectl expose deployment ghost --port=2368
Spec for ingress:
backend
Horizontal Pod Autoscaler
When heapster runs:
$ kubectl get hpa
$ kubectl autoscale --help
DaemonSets
$ kubectl get daemonsets
$ kubectl get ds
Scheduler
NodeSelector based policy:
$ kubectl label node minikube foo=bar
Node Binding through API Server:
$ kubectl proxy 
$ curl -H "Content-Type: application/json" -X POST --data @binding.json http://localhost:8001/api/v1/namespaces/default/pods/foobar-sched/binding
Tains and Tolerations
$ kubectl taint node master foo=bar:NoSchedule
Troubleshooting
$ kubectl describe
$ kubectl logs
$ kubectl exec
$ kubectl get nodes --show-labels
$ kubectl get events
Docs Cluster:
https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster/
https://github.com/kubernetes/kubernetes/wiki/Debugging-FAQ
Role Based Access Control
Role
ClusterRule
Binding
ClusterRoleBinding
$ kubectl create role fluent-reader --verb=get --verb=list --verb=watch --resource=pods
$ kubectl create rolebinding foo --role=fluent-reader --user=minikube
$ kubectl get rolebinding foo -o yaml
Security Contexts
Docs: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
spec
securityCOntext
runAsNonRoot: true
Pod Security Policies
Docs: https://github.com/kubernetes/kubernetes/blob/master/examples/podsecuritypolicy/rbac/README.md
Network Policies
Network isolation at Pod level by using annotations
$ kubectl annotate ns <namespace> "net.beta.kubernetes.io/network-policy={\"ingress\": {\"isolation\": \"DefaultDeny\"}}"


Service <-> Deployment mapping :  Labels & Selectors 
Service <-> Service Mapping : Service URL mapping




------------------------------------------------------------------
				LINUX
------------------------------------------------------------------

1. Find files having the text
find . -type f -print | sed 's/ /\\ /g' | xargs grep -i "your text here"

2. Find files via filename
locate <file-name>

3. To check port status
sudo netstat -ntlp

4. To view space
du -sh *
du -sh * | grep G	-	will show the result if text is having G
df -h

5. telnet <endpoint> <port>		-	To check connection
6. scp <files> user@ip:<location>	- 	To copy files
7. service ufw stop|status|start	-	To enable & disable firewall
8. tcpdump
	- tcpdump is a most powerful and widely used command-line packets sniffer or package analyzer tool which is 
	used to capture or filter TCP/IP packets that received or transferred over a network on a specific interface. 
	It is available under most of the Linux/Unix based operating systems. 
	tcpdump also gives us a option to save captured packets in a file for future analysis. 
	It saves the file in a pcap format, that can be viewed by tcpdump command or a open source GUI based tool 
	called Wireshark (Network Protocol Analyzier) that reads tcpdump pcap format files.
9. tcpdump -c 5
	- top 5 packets
10. tcpdump -D
	- will display available interfaces
11. tcpdump -w 0001.pcap
	- save result in file
	
	
12.netstat
	- netstat (network statistics) is a command line tool for monitoring network connections both incoming and 
	outgoing as well as viewing routing tables, interface statistics etc. netstat is available on all Unix-like 
	Operating Systems and also available on Windows OS as well. It is very useful in terms of network troubleshooting 
	and performance measurement. netstat is one of the most basic network service debugging tools, telling you what 
	ports are open and whether any programs are listening on ports.

13. netstat -a | more
	- Listing all ports (both TCP and UDP) using netstat -a option.
14. netstat -at
	- Listing only TCP (Transmission Control Protocol) port connections using netstat -at.
15. netstat -s
	- Displays statistics by protocol.
	
https://www.tecmint.com/ssh-interview-questions/







------------------------------------------------------------------
				NGINX
------------------------------------------------------------------

1. homepage of nginx : /usr/share/nginx/html/index.html
2. config file of nginx : /etc/nginx/nginx.conf



------------------------------------------------------------------
				DOCKER
------------------------------------------------------------------
1. docker version
	1. docker -v
		- short description
	2. docker --version
		- short description
	3. docker version
		- long description

2. docker info
	- gives you more details like configured account of docker registry etc.

3. Docker run <imagename>
	- To run a container from an image

4. docker image ls
	- to list the images on machine

5. docker rmi $(docker images -q)
	- Delete all images

6. docker rm $(docker ps -a -q)
	- Delete all containers

7. docker build -t <image-name-you-want> .
	- will build the image as per the Dockerfile specified and giving friendly name to docker image

8. docker run -p 4000:80 <image-name>	
	- To run image from local machine which has been saved previously

9. docker push username/repository:tag
	- Pushing image to docker registry
	- 

10. docker login
	- login to your docker hub account

11. docker compose-ps
	- shows running containers with name, command, state and open ports

## List Docker CLI commands
docker
docker container –help

## Display Docker version and info
docker --version
docker version
docker info

## Execute Docker image
docker run hello-world

## List Docker images
docker image ls

## List Docker containers (running, all, all in quiet mode)
docker container ls
docker container ls --all
docker container ls -aq

docker build -t friendlyhello .  # Create image using this directory's Dockerfile
docker run -p 4000:80 friendlyhello  # Run "friendlyname" mapping port 4000 to 80
docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode
docker container ls                                # List all running containers
docker container ls -a             # List all containers, even those not running
docker container stop <hash>           # Gracefully stop the specified container
docker container kill <hash>         # Force shutdown of the specified container
docker container rm <hash>        # Remove specified container from this machine
docker container rm $(docker container ls -a -q)         # Remove all containers
docker image ls -a                             # List all images on this machine
docker image rm <image id>            # Remove specified image from this machine
docker image rm $(docker image ls -a -q)   # Remove all images from this machine
docker login             # Log in this CLI session using your Docker credentials
docker tag <image> username/repository:tag  # Tag <image> for upload to registry
docker push username/repository:tag            # Upload tagged image to registry
docker run username/repository:tag                   # Run image from a registry


docker stack ls                                            # List stacks or apps
docker stack deploy -c <composefile> <appname>  # Run the specified Compose file
docker service ls                 # List running services associated with an app
docker service ps <service>                  # List tasks associated with an app
docker inspect <task or container>                   # Inspect task or container
docker container ls -q                                      # List container IDs
docker stack rm <appname>                             # Tear down an application
docker swarm leave --force      # Take down a single node swarm from the manager


docker container ls --all


## List Docker CLI commands
docker
docker container --help

## Display Docker version and info
docker --version
docker version
docker info

## Execute Docker image
docker run hello-world

## List Docker images
docker image ls

## List Docker containers (running, all, all in quiet mode)
docker container ls
docker container ls --all
docker container ls -aq

Ctrl + P + Q = To exit container without killing it

1. Docker Pull <imagename>
	- Pull the image from web and download it to local.

3. Docker ps
	- To list running containers
4. Docker ps -a
	- To see previously run containers
5. Docker run -it <imagename> sh
	- To go inside container and run user defined commands
6. Docker kill $(docker ps -q)
	- Stop all containers:
7. Docker rm $(docker ps -a -q)
	- Remove all containers
8. Docker rmi $(docker images -q)
	- Remove all docker images

Linked containers on the default bridge network share environment variables.

Originally, the only way to share environment variables between two containers was to link them using the --link flag. This type of variable sharing is not possible with user-defined networks. However, there are superior ways to share environment variables. A few ideas:

Multiple containers can mount a file or directory containing the shared information, using a Docker volume.

Multiple containers can be started together using docker-compose and the compose file can define the shared variables.



RUN A MYSQL Container

1. docker run --name=mysql1 -d mysql/mysql-server:latest
2. docker ps
3. docker logs mysql1 2>&1 | grep GENERATED
4. docker exec -it mysql1 mysql -uroot -p
5. ALTER USER 'root'@'localhost' IDENTIFIED BY 'password';


docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=password -d mysql:5.7

------------------------------------------------------------------
				ANSIBLE
------------------------------------------------------------------

To configure ansible 
create ansible user in all the machine including host
- make sure u have created home directory for ansible and given access to ansible user
got to /home
	- mkdir ansible
	- chown ansible:ansible ansible
generate ssh key and do ssh-copy id
check with
ansible all -m ping
	- to check connection between ansible master and hosts
	
ansible all -a "ls -a /home/ansible/"
	- to list dir of hosts

ansible all -m copy -a "src=test.txt dest=/tmp/test.txt"
	- to copy file to hosts
To view file on nodes follow below steps,
	- ls -al /tmp

ansible onprem -s -m apt -a "name=npm state=present"
	- to install any packages on remote hosts

ansible onprem -s -m apt -a "name=npm state=absent"
	- to remove any packages on remote hosts

ansible onprem -s -m user -a "name=test"
	- to create user on remote host
	
ansible onprem -s -m user -a "name=test state=absent"
	- to remove user on remote host

ansible-playbook test.yaml --extra-vars "hosts=ubuntu gather=yes package=apt"
	- to supply values to variables in playbook [variable are defined in playbook as {{ hosts }}, {{ gather }}, {{ package }}




Ansible host file location : /etc/ansible/hosts

ansible all -m ping
	- will ping all the hosts mentioned in hosts file and give the status
	
﻿------------------------------------------------------------------
				Shell Scripting
-------------------------------------------------------------------

start with "#!bin/bash"
For Loop :
	for i in 1 2 3 4 5
	do
  		echo "Looping ... number $i"
	done

While Loop :
	INPUT_STRING=hello
	while [ "$INPUT_STRING" != "bye" ]
	do
  		echo "Please type something in (bye to quit)"
		read INPUT_STRING
		echo "You typed: $INPUT_STRING"
	done

If..else.. :
	if  [ something ]; then
	 	echo "Something"
	 elif [ something_else ]; then
	   	echo "Something else"
	 else
	   	echo "None of the above"
	fi



